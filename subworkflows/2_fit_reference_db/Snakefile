""" Benchmarking the OptiFit algorithm using an external reference database """
import shutil

# TODO: take a V4 data set and try it against a FL and V4 reference
wildcard_constraints:
    region="bact_v4|bact_full"

subworkflow prep_db:
    workdir:
        "../0_prep_db/"
subworkflow prep_samples:
    workdir:
        "../1_prep_samples/"

leaf_jobs=['optifit', 'cluster_combined']
datasets=["soil"]
refs=["silva"]
regions=['bact_v4']
methods=["open"]
printrefs=['f']
seeds=range(1)

rule targets_fit_ref_db:
    input:
        [target for dataset in datasets for ref in refs for region in regions for method in methods for printref in printrefs for seed in seeds for target in
            [f'results/{dataset}_{ref}_{region}/optifit/method_{method}/printref_{printref}/seed_{seed}/{dataset}_{ref}.{region}.all.unique.optifit_mcc.sensspec',
             f'results/{dataset}_{ref}_{region}/cluster_combined/seed_{seed}/{dataset}_{ref}.{region}.all.unique.opti_mcc.sensspec'
            ]
        ]

rule copy_preclust_inputs:  # because filter.seqs doesn't like hyphens in filepaths
    input:
        filter=prep_samples("data/{dataset}/{ref}/processed/{dataset}.filter"),
        fasta=prep_samples("data/{dataset}/{ref}/processed/{dataset}.fasta"),
        count=prep_samples("data/{dataset}/{ref}/processed/{dataset}.count_table"),
        column=prep_samples("results/{dataset}/{ref}/{dataset}.dist"),
        fasta_db=prep_db("data/{ref}/{ref}.{region}.fasta"),
        tax=prep_db("data/{ref}/{ref}.bacteria.tax")
    output:
        filter="data/{dataset}_{ref}_{region}/inputs/{dataset}.filter",
        fasta="data/{dataset}_{ref}_{region}/inputs/{dataset}.fasta",
        count="data/{dataset}_{ref}_{region}/inputs/{dataset}.count_table",
        column="data/{dataset}_{ref}_{region}/inputs/{dataset}.dist",
        fasta_db="data/{dataset}_{ref}_{region}/inputs/{ref}.{region}.fasta",
        tax="data/{dataset}_{ref}_{region}/inputs/{ref}.bacteria.tax"
    params:
        outdir="data/{dataset}_{ref}_{region}/inputs/"
    shell:
        """
        cp {input.filter} {output.filter}
        cp {input.fasta} {output.fasta}
        cp {input.count} {output.count}
        cp {input.column} {output.column}
        cp {input.fasta_db} {output.fasta_db}
        cp {input.tax} {output.tax}
        """

rule preclust_db:
    input:
        fasta_db=rules.copy_preclust_inputs.output.fasta_db,
        fasta_sample=rules.copy_preclust_inputs.output.fasta,
        tax=rules.copy_preclust_inputs.output.tax,
        hard_filter=rules.copy_preclust_inputs.output.filter
    output:
        fasta="data/{dataset}_{ref}_{region}/preclust_db/{ref}.{region}.filter.unique.precluster.fasta",
        count="data/{dataset}_{ref}_{region}/preclust_db/{ref}.{region}.filter.unique.precluster.pick.count_table",
        tax="data/{dataset}_{ref}_{region}/preclust_db/{ref}.{region}.pick.tax",
        dist="data/{dataset}_{ref}_{region}/preclust_db/{ref}.{region}.filter.unique.precluster.dist"
    params:
        tax="data/{dataset}_{ref}_{region}/preclust_db/{ref}.bacteria.pick.tax",
        outdir="data/{dataset}_{ref}_{region}/preclust_db/"
    resources:
        procs=12,
        walltime_hrs=48
    log:
        "log/{dataset}_{ref}_{region}/preclust_db.log"
    benchmark:
        "benchmarks/{dataset}_{ref}_{region}/preclust_db.txt"
    shell:
        """
        mothur '#set.logfile(name={log}); set.dir(output={params.outdir});

        filter.seqs(fasta={input.fasta_db}, hard={input.hard_filter}, processors={resources.procs});
        unique.seqs(fasta=current);
        pre.cluster(fasta=current, name=current, diffs=2, processors={resources.procs});
        dist.seqs(fasta=current, cutoff=0.03, processors={resources.procs});

        list.seqs(fasta=current);
        get.seqs(accnos=current, taxonomy={input.tax});
        get.seqs(accnos=current, count=current);
        summary.seqs(fasta=current, count=current);
        rename.file(input={params.tax}, new={output.tax}) '
        """

rule cluster_db:
    input:
        dist=rules.preclust_db.output.dist,
        count=rules.preclust_db.output.count
    output:
        list="results/{dataset}_{ref}_{region}/cluster_db/seed_{seed}/{ref}.{region}.filter.unique.precluster.opti_mcc.list",
        steps="results/{dataset}_{ref}_{region}/cluster_db/seed_{seed}/{ref}.{region}.filter.unique.precluster.opti_mcc.steps",
        sensspec="results/{dataset}_{ref}_{region}/cluster_db/seed_{seed}/{ref}.{region}.filter.unique.precluster.opti_mcc.sensspec"
    params:
        outdir="results/{dataset}_{ref}_{region}/cluster_db/seed_{seed}/"
    log:
        "log/{dataset}_{ref}_{region}/cluster_db.seed_{seed}.log"
    benchmark:
        "benchmarks/{dataset}_{ref}_{region}/cluster_db.seed_{seed}.txt"
    shell:
        """
        mothur '#set.logfile(name={log}); set.dir(output={params.outdir});
        set.seed(seed={wildcards.seed});
        cluster(column={input.dist}, count={input.count}, cutoff=0.03) '
        """

rule get_otu_reps_db:
    input:
        list=rules.cluster_db.output.list,
        count=rules.preclust_db.output.count,
        tax=rules.preclust_db.output.tax,
        dist=rules.preclust_db.output.dist
    output:
        tax="results/{dataset}_{ref}_{region}/cluster_db/seed_{seed}/{ref}.{region}.seed_{seed}.opti_mcc.0.03.cons.taxonomy",
        sum="results/{dataset}_{ref}_{region}/cluster_db/seed_{seed}/{ref}.{region}.seed_{seed}.opti_mcc.0.03.cons.tax.summary",
        count="results/{dataset}_{ref}_{region}/cluster_db/seed_{seed}/{ref}.{region}.seed_{seed}.opti_mcc.0.03.rep.count_table"
    params:
        outdir="results/{dataset}_{ref}_{region}/cluster_db/seed_{seed}/"
    log:
        "log/get_otu_reps.{dataset}_{ref}_{region}.seed_{seed}.log"
    benchmark:
        "benchmarks/get_otu_reps.{dataset}_{ref}_{region}.seed_{seed}.txt"
    shell:
        """
        mothur '#set.logfile(name={log}); set.dir(output={params.outdir});
        classify.otu(list={input.list}, count={input.count}, taxonomy={input.tax}, label=0.03);
        get.oturep(column={input.dist}, list={input.list}, count={input.count}, method=abundance) '
        """

rule combine_seqs:
    input:
        fasta_sample=rules.copy_preclust_inputs.output.fasta,
        fasta_db=rules.preclust_db.output.fasta
    output:
        fasta_all="data/{dataset}_{ref}_{region}/combined_seqs/{dataset}_{ref}.{region}.all.fasta",
        fasta_unique="data/{dataset}_{ref}_{region}/combined_seqs/{dataset}_{ref}.{region}.all.unique.fasta",
        count_all="data/{dataset}_{ref}_{region}/combined_seqs/{dataset}_{ref}.{region}.all.count_table",
        accnos_refs="data/{dataset}_{ref}_{region}/combined_seqs/{ref}.{region}.filter.unique.precluster.accnos"
    params:
        outdir="data/{dataset}_{ref}_{region}/combined_seqs/"
    log:
        "log/{dataset}_{ref}_{region}/combine_seqs.log"
    benchmark:
        "benchmarks/{dataset}_{ref}_{region}/combine_seqs.txt"
    shell:
        """
        cat {input} > {output.fasta_all}
        mothur '#set.logfile(name={log}); set.dir(output={params.outdir});
            list.seqs(fasta={input.fasta_sample});
            list.seqs(fasta={input.fasta_db});
            unique.seqs(fasta={output.fasta_all}, format=count)
        '
        """

rule calc_dists_combined:
    input:
        fasta=rules.combine_seqs.output.fasta_unique
    output:
        column="data/{dataset}_{ref}_{region}/combined_seqs/{dataset}_{ref}.{region}.all.unique.dist"
    params:
        outdir="data/{dataset}_{ref}_{region}/combined_seqs/"
    log:
        "log/{dataset}_{ref}_{region}/calc_dists_combined.log"
    benchmark:
        "benchmarks/{dataset}_{ref}_{region}/calc_dists_combined.txt"
    resources:
        procs=16
    shell:
        """
        mothur '#set.logfile(name={log}); set.dir(output={params.outdir});
            dist.seqs(fasta={input.fasta}, cutoff=0.03, processors={resources.procs}) '
        """

# TODO: get cluster.fit to NOT run cluster on ref seqs
rule fit_to_ref_db: # this version is based on Sarah W's email
    input:
        fasta=rules.combine_seqs.output.fasta_unique,
        count=rules.combine_seqs.output.count_all,
        column=rules.calc_dists_combined.output.column,
        accnos=rules.combine_seqs.output.accnos_refs,
        reflist=rules.cluster_db.output.list,
        refcolumn=rules.preclust_db.output.dist,
        reffasta=rules.preclust_db.output.fasta,
        refcount=rules.preclust_db.output.count
    output:
        sensspec='results/{dataset}_{ref}_{region}/optifit/method_{method}/printref_{printref}/seed_{seed}/{dataset}_{ref}.{region}.all.unique.optifit_mcc.sensspec'
    params:
        outdir="results/{dataset}_{ref}_{region}/optifit/method_{method}/printref_{printref}/seed_{seed}/"
    benchmark:
        "benchmarks/{dataset}_{ref}_{region}/optifit.method_{method}.printref_{printref}.seed_{seed}.txt"
    log:
        "log/{dataset}_{ref}_{region}/optifit.method_{method}.printref_{printref}.seed_{seed}.log"
    resources:
        procs=1
    shell:
        """
        mothur "#set.logfile(name={log}); set.dir(output={params.outdir});
        set.seed(seed={wildcards.seed});
        set.current(processors={resources.procs});
        cluster.fit(accnos={input.accnos}, fasta={input.fasta}, count={input.count}, column={input.column}, reflist={input.reflist}, refcolumn={input.refcolumn}, reffasta={input.reffasta}, refcount={input.refcount}, printref={wildcards.printref}, method={wildcards.method}) "
        """
'''
rule fit_to_ref_db_OLD:
    input:
        reflist=rules.cluster_db.output.list,
        refcolumn=rules.preclust_db.output.dist,
        reffasta=rules.preclust_db.output.fasta,
        refcount=rules.preclust_db.output.count,
        fasta=rules.copy_preclust_inputs.output.fasta,
        count=rules.copy_preclust_inputs.output.count,
        column=rules.copy_preclust_inputs.output.column
    output:
        sensspec='results/{dataset}/{ref}/{region}/method_{method}/printref_{printref}/seed_{seed}/{dataset}.optifit_mcc.sensspec'
    params:
        outdir="results/{dataset}/{ref}/{region}/method_{method}/printref_{printref}/seed_{seed}/"
    benchmark:
        "benchmarks/{dataset}/{ref}/{region}/method_{method}/printref_{printref}/seed_{seed}/fit.txt"
    log:
        "log/{dataset}/{ref}/{region}/method_{method}/printref_{printref}/seed_{seed}/fit.log"
    shell:
        """
        mothur "#set.logfile(name={log}); set.dir(output={params.outdir});
        cluster.fit(reflist={input.reflist}, refcolumn={input.refcolumn}, reffasta={input.reffasta},refcount={input.refcount}, fasta={input.fasta}, count={input.count}, column={input.column}, printref={wildcards.printref}, method={wildcards.method}) "
        """
'''

rule cluster_combined:
    input:
        dist=rules.calc_dists_combined.output.column,
        count=rules.combine_seqs.output.count_all
    output:
        list="results/{dataset}_{ref}_{region}/cluster_combined/seed_{seed}/{dataset}_{ref}.{region}.all.unique.opti_mcc.list",
        steps="results/{dataset}_{ref}_{region}/cluster_combined/seed_{seed}/{dataset}_{ref}.{region}.all.unique.opti_mcc.steps",
        sensspec='results/{dataset}_{ref}_{region}/cluster_combined/seed_{seed}/{dataset}_{ref}.{region}.all.unique.opti_mcc.sensspec'
    params:
        outdir="results/{dataset}_{ref}_{region}/cluster_combined/seed_{seed}/"
    log:
        "log/{dataset}_{ref}_{region}/cluster_combined.seed_{seed}.log"
    benchmark:
        "benchmarks/{dataset}_{ref}_{region}/cluster_combined.seed_{seed}.txt"
    shell:
        """
        mothur '#set.logfile(name={log}); set.dir(output={params.outdir});
        set.seed(seed={wildcards.seed});
        cluster(column={input.dist}, count={input.count}, cutoff=0.03) '
        """

